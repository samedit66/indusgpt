services:
  bot:
    build: .
    # keep a TTY open (useful for `develop.watch`)
    tty: true
    working_dir: /app

    # bind-mount your source code (so edits are immediate),
    # persist SQLite + log file, and add a uv cache volume
    volumes:
      # 1) project code → /app, delegated for performance
      - .:/app:delegated
      # 2) persist the SQLite file on the host
      - ./db.sqlite3:/app/db.sqlite3
      # 3) persist the log
      - ./bot.log:/app/bot.log
      # 4) uv’s cache so you don’t re-download on every build
      - uv-cache:/root/.cache/uv:delegated

    environment:
      # enable uv’s optimizations (re-declare here just in case)
      UV_COMPILE_BYTECODE: "1"
      UV_LINK_MODE: "copy"

      # Runtime env vars (pull from your host .env or shell)
      TELEGRAM_BOT_TOKEN: ${TELEGRAM_BOT_TOKEN}
      OPENAI_API_KEY:       ${OPENAI_API_KEY}
      OPENAI_API_BASE_URL:  ${OPENAI_API_BASE_URL}
      MODEL:                ${MODEL}
      GOOGLE_CREDENTIALS_PATH: ${GOOGLE_CREDENTIALS_PATH}
      GOOGLE_SHEET_URL:        ${GOOGLE_SHEET_URL}
      GOOGLE_SHEET_WORKSHEET_NAME: ${GOOGLE_SHEET_WORKSHEET_NAME}

      # force Tortoise-ORM (or anything else) to write to the mounted DB
      DATABASE_URL: "sqlite:///app/db.sqlite3"
      # tell your app where to write logs
      LOG_FILE: "/app/bot.log"

    # By default the Dockerfile’s CMD (uv run python main.py) will run
    command: ["uv", "run", "python", "main.py"]

    restart: unless-stopped

    # === uv “develop.watch” section ===
    # When you run `docker compose up --watch`, Docker Compose
    # will automatically:
    #   • sync local changes `path: .` → `/app`
    #   • rebuild if uv.lock changes
    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - .venv/
            - db.sqlite3
            - bot.log
        - action: rebuild
          path: ./uv.lock

volumes:
  uv-cache: