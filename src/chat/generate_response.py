import logging
from typing import Optional

from pydantic import BaseModel, Field

from .simple_agent import SimpleAgent

from src import types

from .router import router, Intent
from .faq_agent import faq_agent
from .validator import (
    validator,
    ValidAnswer,
    InvalidAnswer,
    NeedsMoreDetails,
)
from .atomic_requests import atomic_separator


class ResponseToUser(BaseModel):
    user_input: str = Field(
        ..., description="The exact text message received from the user."
    )
    response_text: str = Field(..., description="The response generated by the agent.")
    extracted_data: Optional[str] = Field(
        None,
        description="The extracted data from the user input. May be None if the user doesn't provide any.",
    )
    ready_for_next_question: bool = Field(
        False,
        description="Is the user ready to move to the next question?",
    )


async def generate_response(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser | None:
    requests = await atomic_separator(user_input)
    responses = await get_responses_for_requests(
        requests.requests, question, context, instructions
    )
    return await combine_responses(user_input, responses)


async def get_responses_for_requests(
    requests: list[str],
    question: types.Question,
    context: str | None,
    instructions: str,
) -> list[ResponseToUser]:
    responses = []
    for request in requests:
        response = await generate_single_response(
            user_input=request,
            question=question,
            context=context,
            instructions=instructions,
        )
        if not response:
            continue

        responses.append(response)
    return responses


async def combine_responses(
    user_input: str,
    responses: list[ResponseToUser],
) -> ResponseToUser | None:
    logging.info(f"Responses:\n{responses}")

    response_texts = [r.response_text for r in responses if r]
    extracted_datas = [r.extracted_data for r in responses if r and r.extracted_data]
    extracted_data = " ".join(extracted_datas) if extracted_datas else None

    if not response_texts:
        return None

    query = f"""
Combine the following several responses into one.
Requirements:
- Focus your attention on what user is missing to provide - we need these details first.
- Put answers to the asked questions. You may modify responses to not have repeated answers.
- Put the next question after it it exists.
- Make response not too long (4-5 sentences max)
- Save all the given information, but elimate redundant infomation (like if user asked a question, but provided answer to it in one message)
- If only one response exist, leave it as is.
- Answers to the user's question should be full and not shorten.

Responses:
{"\n".join(response_texts)}

Look through the original user input, it may help you make a better response:
{user_input}
"""
    combined_response = await response_maker(query)
    return ResponseToUser(
        user_input=user_input,
        response_text=combined_response,
        extracted_data=extracted_data,
        ready_for_next_question=any(r.ready_for_next_question for r in responses),
    )


async def generate_single_response(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser | None:
    intent = await router(
        user_input,
        context=context,
        instructions=instructions,
        question=question.text,
    )
    logging.info(f"generate_single_response: intent: {intent}")

    match intent:
        case Intent(category="ignore"):
            return None
        case Intent(category="faq"):
            # TODO: Возможно, стоит вынести в отдельную функцию
            agent_response = await faq_agent(
                user_input,
                question_text=question.text,
                instructions=instructions,
                context=context,
            )
            return ResponseToUser(
                user_input=user_input,
                response_text=agent_response,
                extracted_data=None,
                ready_for_next_question=False,
            )
        case _:
            return await evaluate_user_information(
                user_input, question, context, instructions
            )


def expand_query(prompt: str, instructions: str | None = None) -> str:
    if instructions:
        query = f"Strictly follow these instructions before answering: {instructions}\n\n{prompt}"
    else:
        query = prompt
    return query


response_maker = SimpleAgent(
    instructions="""
You're a chill, straight-talking assistant who checks if the user's info meets our rules. Your job is to reply with one of three responses—**confirmation**, **partial answer**, or **denial**—in a short, casual, and respectful way.

## 1. Tone & Attitude
- Keep it super casual—use words like “bro” or “okay bro.”
- No rambling—get straight to the point.
- Be friendly but firm.

## 2. Reply Format
- Use plain text only—no markdown, no styling.
- Keep replies short (4–5 sentences max).
- Only ask questions if something is missing.
- **NEVER** act like the answer is fine if the user is missing info or gave something totally invalid.

## 3. When to Use Each Response Type

- **Confirmation** – All info is correct and complete.  
  - Example: “Alright bro, you’ve got an ICICI corporate account with PayU—let’s move forward.”

- **Partial Answer** – Some info is missing or unclear.  
  - Example: “Okay bro, you’ve got a corporate account, but I need the bank name too.”

- **Denial** – Info doesn’t meet the criteria.  
  - Example: “Sorry bro, that’s a personal account—can’t use it.”

## 4. Corner Cases & Typical Responses

- **What’s a PSP?**  
  “Bro, a PSP is just your Payment Service Provider (like Razorpay, PayU, Cashfree, etc.) that sends money to your account—good to go.”

- **Call me / WhatsApp me**  
  “Bro, no calls needed right now—just write all your answers here so we can move forward.”

- **Voice note**  
  “Bro, can’t listen to voice—write it out and I’ll read it.”

- **How to make PSP / Give me PSP**
  "Bro, we cannot provide you with a payment gateway. Search about Razorpay, PayU or Getepay" 

- **Current/savings/personal account**  
  “Sorry bro, we only work with corporate accounts connected to a PSP—can’t proceed.”

- **Getaway but no corporate bank**  
  “Sorry bro, that won’t work—only corporate bank accounts with a PSP connected.”

- **What details should I provide?**  
  “Bro, I listed all questions above—just answer those so we can start.”

- **Is this legal? / Will I get in trouble?**  
  “Bro, it’s all above—no trouble if you have a PSP-connected corporate account and answer my questions.”

- **You won’t scam me?**  
  “Bro, we’re in this for the long term—5% of volume is real and fair, no scam.”

- **Demand higher percentage (e.g. 30%)**  
  “Bro, our rate is fixed at 5%—take it or leave it.”

- **Selling corporate casino/bookmaker accounts**  
  “Bro, we only need corporate accounts already hooked to a PSP and want profit share—nothing else.”

- **Need a PSP for my gaming site**  
  “Bro, we don’t provide PSP accounts—show me you already have one and we’ll talk profit share.”

- **No GST number**  
  “Bro, GST isn’t needed right now—just show me your PSP-connected corporate account first.”

- **Why access to my account?**  
  “Bro, I explained above—we need to integrate your PSP and monitor transactions, that’s it.”

- **Mention limit out of context (e.g. 25 lakh)**  
  “Bro, limits aren’t the point right now—answer my main questions so we know if we can work.”

- *ok issue but one thing how much transatation are par day in account*
  “We handle over ₹12,000,000+ in daily incoming transactions, focusing on safe, long-term work.”
""",
    expand_query=expand_query,
)


async def evaluate_user_information(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    status = await validator(
        user_input,
        question=question,
        context=context,
        instructions=instructions,
    )
    logging.info(f"evaluate_user_information: Status: {status!r}")

    extracted_data = None
    ready_for_next_question = False
    match status.is_valid:
        case ValidAnswer(extracted_user_answer=extracted_user_answer):
            extracted_data = extracted_user_answer
            ready_for_next_question = True
            prompt = (
                f"User successfully provided the information: '{extracted_user_answer}'. "
                "Tell them that they successfully answered the question."
            )
        case InvalidAnswer(reason_why_invalid=reason_why_invalid):
            prompt = (
                f"The last time user wrote the following message: '{user_input}'."
                f"User has not provided anything useful. "
                "If user says that will get what's missing right now, "
                "tell them that what you need to confirm and hit you back when user gets it.\n"
                "If user says that they don't have what's required by the question, "
                "tell them what without it you cannot proceed further."
                "If user says nonsense, tell them that this is beyond conversation.\n"
                "Ask user for what's is missing right now.\n"
                f"To make up a pretty and useful answer, Use the analysis from other agent why user answer is invalid: '{reason_why_invalid}'."
            )
        case NeedsMoreDetails(
            reason_why_incomplete=reason_why_incomplete,
        ):
            prompt = (
                f"The last time user wrote the following message: '{user_input}'.\n"
                "If user says that they will get what's missing right now, "
                "tell them what you are waiting for what's missing right now.\n"
                "If user says that they don't have what's required by the question, "
                "tell them what without it you cannot proceed further."
                "Ask user for what's is missing right now.\n"
                f"To make up a pretty and useful answer, use the analysis from other agent why user answer is incomplete: '{reason_why_incomplete}'."
            )

    response_text = await response_maker(prompt, instructions=instructions)
    return ResponseToUser(
        user_input=user_input,
        response_text=response_text,
        extracted_data=extracted_data,
        ready_for_next_question=ready_for_next_question,
    )
