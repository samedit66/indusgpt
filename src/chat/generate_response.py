import logging
from typing import Optional

from pydantic import BaseModel, Field

from .simple_agent import SimpleAgent

from src import types

from .router import router, Intent
from .faq_agent import faq_agent
from .validator import (
    validator,
    ValidAnswer,
    InvalidAnswer,
    NeedsMoreDetails,
)
from .atomic_requests import atomic_separator


class ResponseToUser(BaseModel):
    user_input: str = Field(
        ..., description="The exact text message received from the user."
    )
    response_text: str = Field(..., description="The response generated by the agent.")
    extracted_data: Optional[str] = Field(
        None,
        description="The extracted data from the user input. May be None if the user doesn't provide any.",
    )
    ready_for_next_question: bool = Field(
        False,
        description="Is the user ready to move to the next question?",
    )


async def generate_response(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    requests = await atomic_separator(user_input)
    responses = await get_responses_for_requests(
        requests.requests, question, context, instructions
    )
    return combine_responses(user_input, responses)


async def get_responses_for_requests(
    requests: list[str],
    question: types.Question,
    context: str | None,
    instructions: str | None,
) -> list[ResponseToUser]:
    responses = []
    for request in requests:
        response = await generate_single_response(
            user_input=request,
            question=question,
            context=context,
            instructions=instructions,
        )
        responses.append(response)
    return responses


def combine_responses(
    user_input: str,
    responses: list[ResponseToUser],
) -> ResponseToUser:
    response_texts = [r.response_text for r in responses]
    extracted_datas = [
        r.extracted_data for r in responses if r.extracted_data is not None
    ]
    extracted_data = " ".join(extracted_datas) if extracted_datas else None

    return ResponseToUser(
        user_input=user_input,
        response_text=" ".join(response_texts),
        extracted_data=extracted_data,
        ready_for_next_question=any(r.ready_for_next_question for r in responses),
    )


async def generate_single_response(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    intent = await router(user_input, context=context, instructions=instructions)
    logging.info(f"generate_single_response: intent: {intent}")

    match intent:
        case Intent(category="faq"):
            # TODO: Возможно, стоит вынести в отдельную функцию
            agent_response = await faq_agent(
                user_input, question_text=question.text, instructions=instructions
            )
            return ResponseToUser(
                user_input=user_input,
                response_text=agent_response,
                extracted_data=None,
                ready_for_next_question=False,
            )
        case _:
            return await evaluate_user_information(
                user_input, question, context, instructions
            )


def expand_query(prompt: str, instructions: str | None = None) -> str:
    if instructions:
        query = f"Strictly follow these instructions before answering: {instructions}\n\n{prompt}"
    else:
        query = prompt
    return query


response_maker = SimpleAgent(
    instructions="""
You’re a simple, bro-style assistant whose job is to check whether the user’s info fits our criteria and reply in one of three ways—confirmation, partial answer or denial—always in a brief, friendly but firm tone.

## 1. Tone & Attitude
- Very casual, say “bro” or “okay bro.”  
- No fluff—get straight to the point.  
- Always polite and respectful.

## 2. How to Format Your Reply
- **No** Markdown or fancy formatting—just plain text.  
- **Always** keep it under two short sentences.
- **Ask questions** only when some data is missing.
- **Never** ask questions in any other case, just say what user is missings or needs to get.

## 3. When to Use Each Response Type
- **Confirmation**: User has exactly what we need.  
  - Example: “Alright bro, you’ve got an ICICI corporate account with PayU—good to go.”  
- **Partial answer**: They’re missing something.  
  - Example: “Okay bro, you’ve got a corporate account, but I need the bank name.”  
- **Denial**: Their info doesn’t match our requirements.  
  - Example: “Sorry bro, that’s a personal account only—can’t work with it.”

## 4. Special Cases to Watch For
- If they say **no PSP-approved website** (or no website at all), treat it as “good to go” and move on to the next step.  
- If they only have a **personal/savings/current** account, that’s not acceptable—deny.

---

## 5. Corner Cases & Typical Responses

- **What’s a PSP?**  
  “Bro, a PSP is just your Payment Service Provider (like Razorpay, PayU, Cashfree, etc.) that sends money to your account—good to go.”

- **Call me / WhatsApp me**  
  “Bro, no calls needed right now—just write all your answers here so we can move forward.”

- **Voice note**  
  “Bro, can’t listen to voice—write it out and I’ll read it.”

- **Current/savings/personal account**  
  “Sorry bro, we only work with corporate accounts connected to a PSP—can’t proceed.”

- **Getaway but no corporate bank**  
  “Sorry bro, that won’t work—only corporate bank accounts with a PSP connected.”

- **What details should I provide?**  
  “Bro, I listed all questions above—just answer those so we can start.”

- **Is this legal? / Will I get in trouble?**  
  “Bro, it’s all above—no trouble if you have a PSP-connected corporate account and answer my questions.”

- **You won’t scam me?**  
  “Bro, we’re in this for the long term—5% of volume is real and fair, no scam.”

- **Demand higher percentage (e.g. 30%)**  
  “Bro, our rate is fixed at 5%—take it or leave it.”

- **Selling corporate casino/bookmaker accounts**  
  “Bro, we only need corporate accounts already hooked to a PSP and want profit share—nothing else.”

- **Need a PSP for my gaming site**  
  “Bro, we don’t provide PSP accounts—show me you already have one and we’ll talk profit share.”

- **No GST number**  
  “Bro, GST isn’t needed right now—just show me your PSP-connected corporate account first.”

- **Why access to my account?**  
  “Bro, I explained above—we need to integrate your PSP and monitor transactions, that’s it.”

- **Mention limit out of context (e.g. 25 lakh)**  
  “Bro, limits aren’t the point right now—answer my main questions so we know if we can work.”

- *ok issue but one thing how much transatation are par day in account*
  “We handle over ₹12,000,000+ in daily incoming transactions, focusing on safe, long-term work.”
""",
    expand_query=expand_query,
)


async def evaluate_user_information(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    status = await validator(
        user_input,
        question=question,
        context=context,
        instructions=instructions,
    )
    logging.info(f"evaluate_user_information: Status: {status!r}")

    extracted_data = None
    ready_for_next_question = False
    match status.is_valid:
        case ValidAnswer(extracted_user_answer=extracted_user_answer):
            extracted_data = extracted_user_answer
            ready_for_next_question = True
            prompt = (
                f"User successfully provided the information: '{extracted_user_answer}'. "
                "Tell them that they successfully answered the question."
            )
        case InvalidAnswer(reason_why_invalid=reason_why_invalid):
            prompt = (
                f"The last time user wrote the following message: '{user_input}'."
                f"User has not provided anything useful. "
                "If user says that will get what's missing right now, "
                "tell them that what you need to confirm and hit you back when user ready to it."
                f"Use the analysis from other agent why user answer is invalid: '{reason_why_invalid}'."
            )
        case NeedsMoreDetails(
            reason_why_incomplete=reason_why_incomplete,
        ):
            prompt = (
                f"The last time user wrote the following message: '{user_input}'."
                f"Reason why user's answer is incomplete: '{reason_why_incomplete}'."
                "If user says that will get what's missing right now, "
                "tell them that what you need to confirm and hit you back when user ready to it "
                "(appropriate phrase choose based on context - it may be 'let me know when you're ready', "
                "'write me back when you get it - without that we can't proceed' and so on). "
            )

    response_text = await response_maker(prompt, instructions=instructions)
    return ResponseToUser(
        user_input=user_input,
        response_text=response_text,
        extracted_data=extracted_data,
        ready_for_next_question=ready_for_next_question,
    )
