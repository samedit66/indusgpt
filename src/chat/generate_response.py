import logging
from typing import Optional

from pydantic import BaseModel, Field

from .simple_agent import SimpleAgent

from src import types

from .router import router, Intent
from .faq_agent import faq_agent
from .validator import (
    validator,
    ValidAnswer,
    InvalidAnswer,
    NeedsMoreDetails,
)
from .atomic_requests import atomic_separator


class ResponseToUser(BaseModel):
    user_input: str = Field(
        ..., description="The exact text message received from the user."
    )
    response_text: str = Field(..., description="The response generated by the agent.")
    extracted_data: Optional[str] = Field(
        None,
        description="The extracted data from the user input. May be None if the user doesn't provide any.",
    )
    ready_for_next_question: bool = Field(
        False,
        description="Is the user ready to move to the next question?",
    )


async def generate_response(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    requests = await atomic_separator(user_input)
    responses = await get_responses_for_requests(
        requests.requests, question, context, instructions
    )
    return combine_responses(user_input, responses)


async def get_responses_for_requests(
    requests: list[str],
    question: types.Question,
    context: str | None,
    instructions: str | None,
) -> list[ResponseToUser]:
    responses = []
    for request in requests:
        response = await generate_single_response(
            user_input=request,
            question=question,
            context=context,
            instructions=instructions,
        )
        responses.append(response)
    return responses


def combine_responses(
    user_input: str,
    responses: list[ResponseToUser],
) -> ResponseToUser:
    response_texts = [r.response_text for r in responses]
    extracted_datas = [
        r.extracted_data for r in responses if r.extracted_data is not None
    ]
    extracted_data = " ".join(extracted_datas) if extracted_datas else None

    return ResponseToUser(
        user_input=user_input,
        response_text=" ".join(response_texts),
        extracted_data=extracted_data,
        ready_for_next_question=any(r.ready_for_next_question for r in responses),
    )


async def generate_single_response(
    user_input: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    intent = await router(user_input, context=context, instructions=instructions)

    match intent:
        case Intent(category="faq"):
            # TODO: Возможно, стоит вынести в отдельную функцию
            agent_response = await faq_agent(
                user_input, question_text=question.text, instructions=instructions
            )
            return ResponseToUser(
                user_input=user_input,
                response_text=agent_response,
                extracted_data=None,
                ready_for_next_question=False,
            )
        case _:
            return await evaluate_user_information(
                user_input, question, context, instructions
            )


def expand_query(prompt: str, instructions: str | None = None) -> str:
    if instructions:
        query = f"Strictly follow these instructions before answering: {instructions}\n\n{prompt}"
    else:
        query = prompt
    return query


response_maker = SimpleAgent(
    instructions="""
You’re a simple, bro-style assistant whose job is to check whether the user’s info fits our criteria and reply in one of three ways—confirmation, partial answer or denial—always in a brief, friendly but firm tone.

## 1. Tone & Attitude
- Very casual, say “bro” or “okay bro.”  
- No fluff—get straight to the point.  
- Always polite and respectful.

## 2. How to Format Your Reply
- **No** Markdown or fancy formatting—just plain text.  
- **Always** keep it under two short sentences.  
- **Never** ask the user any questions.

## 3. When to Use Each Response Type
- **Confirmation**: User has exactly what we need.  
  - Example: “Alright bro, you’ve got an ICICI corporate account with PayU—good to go.”  
- **Partial answer**: They’re missing something.  
  - Example: “Okay bro, you’ve got a corporate account, but I need the bank name.”  
- **Denial**: Their info doesn’t match our requirements.  
  - Example: “Sorry bro, that’s a personal account only—can’t work with it.”

## 4. Special Cases to Watch For
- If they say **no PSP-approved website** (or no website at all), treat it as “good to go” and move on to the next step.  
- If they only have a **personal/savings/current** account, that’s not acceptable—deny.

---

## 5. Corner Cases & Typical Responses

- **What’s a PSP?**  
  “Bro, a PSP is just your Payment Service Provider (like Razorpay, PayU, Cashfree, etc.) that sends money to your account—good to go.”

- **Call me / WhatsApp me**  
  “Bro, no calls needed right now—just write all your answers here so we can move forward.”

- **Voice note**  
  “Bro, can’t listen to voice—write it out and I’ll read it.”

- **Current/savings/personal account**  
  “Sorry bro, we only work with corporate accounts connected to a PSP—can’t proceed.”

- **Getaway but no corporate bank**  
  “Sorry bro, that won’t work—only corporate bank accounts with a PSP connected.”

- **What details should I provide?**  
  “Bro, I listed all questions above—just answer those so we can start.”

- **Is this legal? / Will I get in trouble?**  
  “Bro, it’s all above—no trouble if you have a PSP-connected corporate account and answer my questions.”

- **You won’t scam me?**  
  “Bro, we’re in this for the long term—5% of volume is real and fair, no scam.”

- **Demand higher percentage (e.g. 30%)**  
  “Bro, our rate is fixed at 5% after PSP fees—take it or leave it.”

- **Selling corporate casino/bookmaker accounts**  
  “Bro, we only need corporate accounts already hooked to a PSP and want profit share—nothing else.”

- **Need a PSP for my gaming site**  
  “Bro, we don’t provide PSP accounts—show me you already have one and we’ll talk profit share.”

- **No GST number**  
  “Bro, GST isn’t needed right now—just show me your PSP-connected corporate account first.”

- **Why access to my account?**  
  “Bro, I explained above—we need to integrate your PSP and monitor transactions, that’s it.”

- **Mention limit out of context (e.g. 25 lakh)**  
  “Bro, limits aren’t the point right now—answer my main questions so we know if we can work.”
""",
    expand_query=expand_query,
)


async def evaluate_user_information(
    user_information: str,
    question: types.Question,
    context: str | None = None,
    instructions: str | None = None,
) -> ResponseToUser:
    logging.info(f"User context: {context!r}")

    status = await validator(
        user_information,
        question=question,
        context=context,
        instructions=instructions,
    )
    logging.info(status)

    match status.is_valid:
        case ValidAnswer(extracted_data=extracted_data):
            prompt = (
                f"User successfully provided the information: '{extracted_data}'. "
                "Tell them that they are good to go and we can proceed with the next question."
            )
        case InvalidAnswer(reason_why_invalid=reason_why_invalid):
            prompt = (
                f"User has not provided anything useful. "
                "If user says that will get what's missing right now, "
                "tell them that it's okay and when they are ready they should hit you up."
                f"Use the analysis from other agent why user answer is invalid: '{reason_why_invalid}'."
            )
        case NeedsMoreDetails(
            extracted_data=extracted_data,
            reason_why_incomplete=reason_why_incomplete,
        ):
            prompt = (
                f"User has provided some information: '{extracted_data}'. "
                "If user says that they will get what's missing right now, "
                "tell them that it's okay and when they are ready they should hit you up."
                f"Use the analysis from other agent why user answer is incomplete: '{reason_why_incomplete}'."
            )
    logging.info(f"{prompt!r}")

    agent_response = await response_maker(prompt, instructions=instructions)
    logging.info(agent_response)

    return ResponseToUser(
        user_input=user_information,
        response_text=agent_response,
        extracted_data=status.is_valid.extracted_data,
        ready_for_next_question=isinstance(status.is_valid, ValidAnswer),
    )
